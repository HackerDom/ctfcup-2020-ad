Author: @capitanbanana

Сервис состоит из трех частей:
1. ExecutorService - основной сервис, авторизовывает пользователей, проксирует авторизованные запросы к хранилищу. Хранит данные в 
2. VictimsQueue - ни разу не queue(кривой нейминг случается), но просто хранилка без авторизации, в которую проксирует авторизованные запросы ExecutorService
3. Nginx - обычно проксирует запросы в ExecutorService, но не всегда:)

# Vuln1.

Под капотом у ExecutorService есть стейт, в котором он и хранит все данные, если какой-то пользовательский запрос меняет состояние, то сначала он пишется на диск операция, и только затем, в случае успеха она применяется к состоянию. Раз в n секунд, стейт снапшотится на диск и оплог шринкается. Чтобы шринкнуть оплог, состояние подымается из снапшота, дочитывается оплог, блокируется запись в оплог, дочитвается хвостик и после этого восстановленное состояние подменяет текущее. 
В оплоге опперации выглядят следующим образом:
```
int Marker
int OpCode
...content
int ErrorMarker, если вдруг при записи она развалилась
```
Важно заметить, что запись в оплог не атомарна, часть операции может записаться, а часть нет. Если во время чтения оплога, что-то пошло не так, то ищется ближайший маркер обозначающий начало операции и оплог читается с этого места. Используя эту особенность можно украсть флаги из Command.Admins, назначив себя админом любой команды. Для этого нужно послать запрос который запишет в оплог операцию, первая часть которой будет записана на диск и сериализуется как AddCommandAdmin операция для атакуемой команды, а вторая развалится и испортит оплог. Во время восстановления стейта из оплога, сервис замтетит, что оплог испорчен и будет искать следующую операцию, прочитает AddCommandAdmin и применит ее без валидации. Подробности смотри в сплойте.

# Vuln2.

Конфиг nginx-а, за которым выставлен ExecutorService, выглядит следующим образом
```
http {

  map $cookie_backend $upstream {
    default      qexecute:8001;
    "~(?<backend>.*)" $backend;
  }

    server {
        listen 9000;

	 location / {
			resolver 127.0.0.11;
        		proxy_pass http://$upstream;
	        }
	}
    }
```
И если прийти на него c кукой backend=storage:8000, то он спроксирует запросы на хранлищие


