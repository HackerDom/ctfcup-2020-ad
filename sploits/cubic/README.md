# Вулна 1

AuthManager регистрирует пользователя, умножая его куб `priv_cube` на базовый куб, который вращается `F U R U'` какое-то кол-во раз (`priv_key`).

Можно [найти](http://www.mzrg.com/rubik/orders.shtml) или самому повертеть (как руками, так и в коде) базовый куб и узнать, что этот элемент имеет период 7. Так как кубиков, на которые домножается `priv_cube` всего 7, вариантов `priv_cube`, получаемых из `pub_cube` ползователя тоже 7.

Нужно взять `pub_cube` и вращать его `U R' U' F'`, пока не восстановится `priv_key`.

[сплойт](exploit1.py)

Закрыться можно, поменяв базовый куб на любой другой. Или вообще убрав зависимость `pub_cube` от `priv_cube` (но тогда надо хранить в базе их соответствие).

# Вулна 2

В Cipher реализован ElGamal. Публично доступны `pub_cube` и `ciphercubes`. Так как максимальный период вращения любого куба - 1260, можно просто локально попробовать раздекрпитить на всех таких `x`.

[сплойт](exploit2.py)

Просто поменять алго не получится, потому что чексистема проверяет, что дефолтный `Cipher` может раздекрпитить с известными ему параметрами.

Можно заметить, что в `decrypt` блоки текста сначала анпадятся, а потом собираются во флаг.

Поэтому в `encrypt` можно вместо `msg = split_msg(msg)` делить на блоки так:`msg = [bytes([x]) + urandom(6) + b'\7' for x in msg]` или генерировать пустые блоки `urandom(7) + b'\8'`
Этого достаточно для того, чтобы нельзя было в эксплойте нормально различить флаг от рандомных байтов.